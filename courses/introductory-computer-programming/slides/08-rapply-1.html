---
layout: remark
title: Replicate and the Apply Family of Functions - 1
subtitle: Introductory Computer Programming
author: Deepayan Sarkar
mathjax: true
---

<!--  

# Topics 

* Replicating a simulation experiment

* The `*apply()` family of functions

* Functions can be arguments of other functions

* `do.call()`

-->


# Loop alternatives

* R has several general purpose functions that provide alternatives to loops

* We will discuss two of the main approaches today: 

	- `replicate()` for repeating a simulation experiment
	
	- Various `*apply()` functions to loop over varying function arguments 

* These are not necessarily more efficient than loops (unlike true vectorized operations)

* However, they are conceptually clearer (and easier to parallelize)




---

layout: true

# Replicating a simulation experiment

---

* Consider this example from our previous assignment:


```r
n <- 20
x <- sample(n, 2)
max(x) %% min(x) == 0
```

```
[1] TRUE
```

* To estimate the probability of this event, we want to run it several
  times and compute proportion

---

* We have seen how to do this using a loop

* An alternative approach is to use the `replicate()` function


```r
replicate(10, {
    x <- sample(n, 2)
    max(x) %% min(x) == 0
})
```

```
 [1]  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE
```

* `replicate()` takes the _expression_ supplied as its second argument
  and evauates it multiple times


```r
s <- replicate(5000, {
    x <- sample(n, 2)
    max(x) %% min(x) == 0
})
sum(s) / length(s) # estimated probability of success
```

```
[1] 0.247
```

---

layout: true

# Return value of `replicate()`

---

* The return value of `replicate()` depends on what the expression returns when evaluated

* In the above example, each evaluation results in a scalar logical

* In that case, the results are aggregated to produce a vector
--

* If the result is always a vector of same length (greater than one), the result is combined into a matrix


```r
quantile(rnorm(500), probs = c(0.25, 0.5, 0.75))
```

```
        25%         50%         75% 
-0.75265972  0.03947837  0.77064099 
```

```r
replicate(6, quantile(rnorm(500), probs = c(0.25, 0.5, 0.75)))
```

```
          [,1]       [,2]        [,3]        [,4]        [,5]       [,6]
25% -0.6079280 -0.5713379 -0.65439243 -0.71881653 -0.65383832 -0.7047550
50%  0.1102361  0.0160377 -0.06546112  0.02669952  0.01825581 -0.0654410
75%  0.7187132  0.7002812  0.68018121  0.61500181  0.69690695  0.5951717
```

---

* If the result has inconsistent length, the result is a list


```r
set.seed(20200101)
replicate(6, unique(sample(10, 5, replace = TRUE)))
```

```
[[1]]
[1] 1 4 5 8

[[2]]
[1] 4 7 8 6

[[3]]
[1] 10  9  5  2  1

[[4]]
[1] 6 4 1 2

[[5]]
[1] 6 9 2 3

[[6]]
[1] 1 9 6 2 4
```

---

* This may sometimes lead to unanticipated behaviour


```r
set.seed(20200101)
replicate(2, unique(sample(10, 5, replace = TRUE)))
```

```
     [,1] [,2]
[1,]    1    4
[2,]    4    7
[3,]    5    8
[4,]    8    6
```
--

* When output length is known to be variable, it is better to
  explicitly disable simplification


```r
set.seed(20200101)
replicate(2, unique(sample(10, 5, replace = TRUE)), simplify = FALSE) # always return list
```

```
[[1]]
[1] 1 4 5 8

[[2]]
[1] 4 7 8 6
```

---

layout: false

# The `*apply()` family of functions

* `replicate()` re-evaluates the same expression multiple times

* We often want to something similar:

	- Evaluate the same expression multiple times, but with different arguments
	
* This is what the various `*apply()` functions are intended for

---

layout: true

# The `lapply()` function

---

* The most basic apply-type function is `lapply()`

* It takes two mandatory arguments: `lapply(X, FUN)`

	- `X` is a vector object, with `i`-th element given by `X[[i]]`

	- `FUN` is a function
	
* The result is a _list_ object, with the same length as `X`

* The `i`-th element of the result is `FUN(X[[i]])`

---

* Example: 


```r
lapply(1:5, sample)
```

```
[[1]]
[1] 1

[[2]]
[1] 2 1

[[3]]
[1] 1 3 2

[[4]]
[1] 2 1 4 3

[[5]]
[1] 4 1 3 5 2
```

* This is essentially a "vectorized" version of the for loop


```r
ans <- list()
for (i in 1:5) ans[[i]] <- sample(i) # sample(n) produces a random permutation of 1:n
```

---

* Unlike `replicate()`, the second argument of `lapply()` is not an expression
	
* In other words, `lapply()` does not do non-standard evaluation — whereas `replicate()` does
	
* `lapply()` _always_ returns a list — similar to `simplify = FALSE` in `replicate()`
--

* The somewhat novel feature of `lapply()` is that the `FUN` argument must be a _function_

* This is actually another important difference between R and C: 

	- Functions are not "special"
	
	- They can be assigned to variables
	
	- They can be supplied as arguments to other functions
	
	- They can even be "anonymous", i.e., they don't need to be
      associated with a name
	  
	- In short, they behave just as any other conventional object (vectors, lists, etc.)
	
---

* In fact, it is expected that R users will be able to write short functions when necessary

* Consider our previous example:


```r
lapply(1:5, sample)
```

* This is conceptually equivalent to 


```r
ans <- list()
for (i in 1:5)
    ans[[i]] <- sample(i)
```

* But suppose we instead want


```r
for (i in 1:5)
    ans[[i]] <- sample(10, i, replace = TRUE)
```

---

* `FUN = sample` will no longer serve our purpose, but we can instead define


```r
sample_of_size <- function(i)
{
    return(sample(10, i, replace = TRUE))
}
lapply(1:5, FUN = sample_of_size)
```

```
[[1]]
[1] 2

[[2]]
[1]  5 10

[[3]]
[1]  5  9 10

[[4]]
[1]  9 10 10  8

[[5]]
[1] 4 3 7 8 3
```

---

* In fact, there is no need to _name_ the function by storing it in a variable


```r
lapply(1:5, FUN = function(i) sample(10, i, replace = TRUE))
```

```
[[1]]
[1] 1

[[2]]
[1] 9 8

[[3]]
[1] 5 9 7

[[4]]
[1] 7 9 9 3

[[5]]
[1] 6 8 4 8 5
```

* This idea is often a big conceptual stumbling block for new R users

---

* A potentially useful feature of `lapply()`:


```r
lapply(X, FUN, ...) # with further arguments
```

* is equivalent to


```r
for (i in seq_len(length(X)))
    ans[[i]] <- FUN(X[[i]], ...)
```

---

* For example, this allows


```r
str(sample)
```

```
function (x, size, replace = FALSE, prob = NULL)  
```

```r
lapply(1:5, FUN = sample, size = 20, replace = TRUE)
```

```
[[1]]
 [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1

[[2]]
 [1] 1 1 1 2 1 2 2 2 1 2 2 2 1 2 1 1 1 2 1 2

[[3]]
 [1] 1 3 1 3 1 3 1 3 2 1 3 3 2 1 1 3 1 2 2 3

[[4]]
 [1] 2 3 4 1 1 2 3 1 1 2 1 3 2 2 3 4 2 4 1 1

[[5]]
 [1] 5 2 3 5 4 2 2 2 5 4 2 4 4 2 1 5 3 5 3 2
```

---

* As named arguments match in preference to position, we can even do


```r
lapply(1:6, FUN = sample, x = month.abb, replace = TRUE) # sample(x = month.abb, size = i, replace = TRUE)
```

```
[[1]]
[1] "Mar"

[[2]]
[1] "Sep" "Jul"

[[3]]
[1] "Oct" "Aug" "Jun"

[[4]]
[1] "Jan" "Aug" "Nov" "Sep"

[[5]]
[1] "Sep" "Aug" "Sep" "Feb" "Sep"

[[6]]
[1] "Mar" "Aug" "Feb" "Oct" "Jun" "Jun"
```

---

* Another example: $N(0, \sigma^2)$ variates with varying $\sigma$


```r
str(rnorm)
```

```
function (n, mean = 0, sd = 1)  
```

```r
str(lapply(1:5, FUN = rnorm, n = 1, mean = 0))
```

```
List of 5
 $ : num 0.508
 $ : num 3.22
 $ : num -0.526
 $ : num -2.95
 $ : num -5.52
```

* But much easier to do directly using vectorization


```r
rnorm(5, mean = 0, sd = 1:5)
```

```
[1]  0.3954458 -0.1941855 -0.3006131  3.1952913  6.6842178
```

---

* A more complicated example: IQR of 1000 $N(0, \sigma^2)$ variates with varying $\sigma$


```r
str(lapply(1:8, function(s) IQR(rnorm(n = 1000, mean = 0, sd = s))))
```

```
List of 8
 $ : num 1.26
 $ : num 2.74
 $ : num 4.11
 $ : num 5.24
 $ : num 6.75
 $ : num 7.7
 $ : num 8.86
 $ : num 10.4
```

---

layout: true

# `sapply()` : simplifying results to vector / array

---

* `sapply()` is essentially the same as `lapply()`, but simplifies result if possible


```r
sapply(1:8, function(s) IQR(rnorm(n = 1000, mean = 0, sd = s)))
```

```
[1]  1.339407  2.731552  4.163295  5.529104  6.599158  7.826212  9.030755 10.664930
```


```r
sapply(1:6, function(s) quantile(rnorm(n = 1000, mean = 0, sd = s)))
```

```
            [,1]       [,2]        [,3]         [,4]        [,5]        [,6]
0%   -3.67289060 -6.3374479 -10.6534143 -11.51621862 -16.3487604 -18.6006569
25%  -0.67073841 -1.3168766  -2.2246628  -2.74282634  -3.1348198  -4.0620119
50%  -0.02022398 -0.1041655  -0.0354455  -0.03241321   0.3150866   0.3221047
75%   0.64222333  1.3005396   2.0428048   2.86558657   3.5318173   4.2691608
100%  2.89843111  7.9386912   8.7524743  16.57510944  14.8181359  20.4662170
```

---

layout: true

# `apply()` : Apply function to rows / columns of a matrix

---

* We will talk about matrix operations in R in more detail later

* It is often useful to apply a function on rows or columns of a matrix


```r
m1 <- matrix(0, nrow = 1000, ncol = 8)
for (i in 1:8)
    m1[, i] <- rnorm(1000, mean = 0, sd = i)
str(m1)
```

```
 num [1:1000, 1:8] -0.207 0.11 1.109 -0.434 -0.284 ...
```

* Note that this is essentially the same as


```r
m2 <- sapply(1:8, function(s) rnorm(n = 1000, mean = 0, sd = s))
str(m2)
```

```
 num [1:1000, 1:8] -0.819 0.156 -0.93 1.145 -0.601 ...
```

---

* Suppose we want to compute the mean for each column of `m1`

* There are several ways to do this:

	- Loop over columns
	
	- Write this as a matrix operation (will discuss later)
	
	- Use the `colMeans()` or `colSums()` function
	

```r
colMeans(m1)
```

```
[1] -0.004457624 -0.109893585 -0.072194233 -0.025676205  0.015111769 -0.302844079 -0.252410061
[8] -0.123560718
```

```r
colSums(m1) / nrow(m1)
```

```
[1] -0.004457624 -0.109893585 -0.072194233 -0.025676205  0.015111769 -0.302844079 -0.252410061
[8] -0.123560718
```

---

* However, `colMeans()` / `colSums()` and `rowMeans()` / `rowSums()` are special

* Other summary functions do not have a built-in row-wise / column-wise versions

* `apply()` allows arbitrary functions to be called per row (`MARGIN=1`) or column (`MARGIN=2`) 


```r
apply(m1, 2, mean)
```

```
[1] -0.004457624 -0.109893585 -0.072194233 -0.025676205  0.015111769 -0.302844079 -0.252410061
[8] -0.123560718
```

```r
apply(m1, 2, sd)
```

```
[1] 1.022618 1.932372 3.019592 4.038631 5.200633 6.184044 6.874712 7.767629
```

```r
apply(m1, 2, IQR)
```

```
[1]  1.344224  2.558548  4.061610  5.655623  6.745589  8.085373  9.239304 10.573359
```

---

* `apply()` also allows additional arguments to be specified


```r
apply(m1, 2, quantile, probs = c(0.25, 0.75))
```

```
          [,1]      [,2]      [,3]      [,4]      [,5]      [,6]      [,7]      [,8]
25% -0.6521793 -1.359109 -2.112339 -2.763942 -3.435196 -4.441023 -4.858535 -5.332361
75%  0.6920444  1.199439  1.949271  2.891681  3.310393  3.644350  4.380769  5.240998
```

* As well as unnamed functions


```r
apply(m1, 2, function(x) median(abs(x)))
```

```
[1] 0.6786068 1.2588601 2.0411513 2.8178597 3.3824512 4.0650801 4.6527861 5.2765122
```

---

* Applying a function row-wise


```r
apply(m1, 1, function(x) which.max(abs(x)))
```

```
   [1] 5 8 4 5 6 7 8 4 8 8 7 8 7 6 7 7 4 6 8 8 6 7 8 4 6 8 8 6 7 5 8 8 7 7 8 8 4 7 6 7 5 7 7 3 8 7 8
  [48] 8 8 6 6 7 6 7 6 7 7 6 7 5 8 8 8 8 5 7 7 5 8 6 8 7 5 8 6 8 7 7 8 8 7 6 5 7 6 5 3 6 7 7 8 7 8 5
  [95] 7 7 4 7 8 5 4 4 8 5 6 6 5 8 3 3 7 6 5 8 7 7 5 8 5 6 6 8 8 7 6 7 7 5 4 6 7 8 8 5 4 8 8 8 7 6 8
 [142] 6 7 6 7 6 8 5 7 5 5 5 7 8 8 5 7 7 5 3 8 7 8 7 7 3 7 7 5 8 8 8 8 4 5 8 8 3 5 8 6 6 5 7 6 7 7 8
 [189] 8 7 7 7 8 7 7 7 5 6 7 7 8 8 7 8 8 7 4 5 6 7 7 7 3 8 7 8 6 6 6 8 6 7 6 8 8 8 7 8 5 6 6 6 8 7 8
 [236] 6 5 7 8 5 6 8 3 7 8 4 8 8 5 7 6 8 7 7 6 6 6 5 4 8 6 8 7 8 8 7 6 6 4 8 6 6 8 6 4 8 8 7 7 7 8 7
 [283] 6 6 6 6 3 8 6 8 8 7 5 6 8 5 6 7 5 8 5 6 8 4 5 8 8 5 7 7 6 5 8 7 7 2 8 8 7 6 6 8 8 6 6 8 7 5 5
 [330] 8 7 5 6 5 4 6 5 8 5 8 6 7 8 4 8 4 7 4 6 6 5 7 6 5 4 8 3 8 7 6 7 6 8 8 7 5 6 7 7 4 6 4 8 6 7 8
 [377] 3 8 6 7 7 8 8 7 5 8 8 7 5 7 8 8 7 7 8 8 7 4 6 5 6 8 8 6 6 7 6 8 7 6 6 5 6 7 8 7 8 7 7 4 5 4 4
 [424] 5 4 5 5 5 8 7 8 6 8 7 8 7 5 6 8 5 6 6 3 8 4 6 6 3 6 8 7 8 8 6 8 8 7 8 7 8 7 8 8 7 6 7 5 8 8 8
 [471] 7 7 8 5 6 8 4 6 5 6 8 8 6 6 8 5 7 7 5 6 6 8 8 8 8 6 8 4 6 5 7 8 5 8 7 8 7 6 7 6 5 8 7 8 8 7 5
 [518] 5 5 8 8 2 7 8 7 8 4 7 4 7 4 7 7 7 4 8 8 7 6 8 5 8 6 6 5 8 8 7 7 7 8 7 8 7 8 7 7 8 8 6 7 8 7 8
 [565] 7 5 6 7 7 8 7 5 4 5 5 6 7 7 5 6 8 8 7 6 7 8 7 5 5 7 6 6 5 6 5 6 8 8 8 6 8 5 8 4 7 8 6 4 3 8 8
 [612] 7 8 8 6 8 7 5 8 6 7 6 8 7 8 3 7 7 3 8 8 8 6 7 8 7 8 6 8 5 5 7 7 6 8 8 8 4 7 8 8 7 2 5 6 5 7 4
 [659] 4 8 8 8 5 8 5 8 5 7 6 8 8 8 7 7 8 5 7 7 8 4 5 8 8 7 6 6 6 6 6 5 8 4 6 6 8 8 8 7 6 7 7 6 8 8 4
 [706] 7 7 4 8 5 8 7 7 7 6 7 7 5 5 8 6 7 5 8 7 6 8 7 7 5 8 8 6 8 7 6 6 8 8 8 5 4 8 5 8 6 8 6 4 6 6 6
 [753] 6 5 5 5 7 7 7 8 7 8 4 7 7 7 3 4 3 5 6 8 8 8 7 8 6 6 5 7 8 8 7 8 7 6 8 8 8 7 6 6 4 7 8 5 6 5 5
 [800] 6 8 7 7 6 7 7 4 8 7 4 6 8 8 4 7 7 8 7 8 6 8 6 8 8 6 4 6 7 6 6 6 8 8 7 8 5 8 7 7 8 7 7 7 5 8 8
 [847] 7 7 8 8 3 6 7 7 6 6 7 6 5 8 6 7 6 6 6 7 3 8 8 6 8 5 7 6 7 5 7 7 6 7 7 8 7 6 7 5 7 8 7 8 8 5 7
 [894] 8 5 4 4 4 7 6 6 4 6 7 6 8 7 6 8 6 6 7 5 5 6 8 5 8 7 7 5 6 7 3 7 8 5 8 8 7 8 6 5 6 8 7 5 6 6 5
 [941] 8 5 8 8 7 8 5 4 7 8 8 8 6 5 5 6 3 8 8 8 6 8 5 8 8 6 5 7 7 8 3 8 8 6 7 7 8 8 6 7 8 7 5 8 8 6 7
 [988] 3 8 7 8 7 7 6 7 7 8 8 7 8
```

---

* Applying a function row-wise


```r
wmax <- apply(m1, 1, function(x) which.max(abs(x)))
table(wmax)
```

```
wmax
  2   3   4   5   6   7   8 
  3  25  60 135 199 266 312 
```

```r
barplot(table(wmax))
```

![plot of chunk unnamed-chunk-31](figures/rapply-1-unnamed-chunk-31-1.png)

---

* `apply()` can also summarize over margins of higher-dimensional arrays


```r
Titanic[,,2,]
```

```
, , Survived = No

      Sex
Class  Male Female
  1st   118      4
  2nd   154     13
  3rd   387     89
  Crew  670      3

, , Survived = Yes

      Sex
Class  Male Female
  1st    57    140
  2nd    14     80
  3rd    75     76
  Crew  192     20
```


---

* `apply()` can also summarize over margins of higher-dimensional arrays


```r
apply(Titanic[,,2,], MARGIN = 3, sum)
```

```
  No  Yes 
1438  654 
```

* More interestingly, the summary can happen over multiple dimensions


```r
apply(Titanic[,,2,], MARGIN = c(2, 3), sum)
```

```
        Survived
Sex        No Yes
  Male   1329 338
  Female  109 316
```



---

layout: false
class: middle, center

# Questions?

