---
layout: remark
title: Replicate and the Apply Family of Functions - 3
subtitle: Introductory Computer Programming
author: Deepayan Sarkar
mathjax: true
---

<!--  

# Topics 

* Replicating a simulation experiment

* The `*apply()` family of functions

* Functions can be arguments of other functions

* `do.call()`

-->


# Recap

* `lapply(X, FUN)` applies the function `FUN` on each element of `X`
	
* Extra arguments to `FUN` can also be supplied (but these remain fixed for each call)
	
* These extra arguments can be named to control which argument of `FUN` varies




---

layout: true

# The `lapply()` function

---

* Example: $N(0, \sigma^2)$ variates with varying $\sigma$


```r
str(rnorm)
```

```
function (n, mean = 0, sd = 1)  
```

```r
str(lapply(1:5, FUN = rnorm, n = 1, mean = 0))
```

```
List of 5
 $ : num 0.535
 $ : num 0.874
 $ : num -1.46
 $ : num -0.595
 $ : num 2.46
```
--


* But much easier to do directly using vectorization


```r
rnorm(5, mean = 0, sd = 1:5)
```

```
[1] -0.3362657 -1.9835795  3.4634113 -5.5445065 -8.8559369
```

---

* A more complicated example: IQR of 1000 $N(0, \sigma^2)$ variates with varying $\sigma$


```r
str(lapply(1:8, function(s) IQR(rnorm(n = 1000, mean = 0, sd = s))))
```

```
List of 8
 $ : num 1.36
 $ : num 2.66
 $ : num 4.08
 $ : num 5.43
 $ : num 6.72
 $ : num 8.07
 $ : num 9.49
 $ : num 10.5
```

---

layout: true

# `sapply()` : simplifying results to vector / array

---

* `sapply()` is essentially the same as `lapply()`, but simplifies result if possible


```r
sapply(1:8, function(s) IQR(rnorm(n = 1000, mean = 0, sd = s)))
```

```
[1]  1.303945  2.674963  4.079763  5.118297  6.583926  8.199992  9.997719 10.781251
```


```r
sapply(1:6, function(s) quantile(rnorm(n = 1000, mean = 0, sd = s)))
```

```
             [,1]        [,2]        [,3]         [,4]       [,5]        [,6]
0%   -2.944898968 -6.52565888 -9.09942895 -12.65315771 -15.310699 -18.3959848
25%  -0.655675290 -1.32537739 -2.02835824  -2.55312168  -3.320372  -4.0370629
50%   0.002239151  0.06448223 -0.05558022  -0.04932861   0.208617  -0.1032417
75%   0.647233141  1.38658912  1.79530092   2.49533623   3.582333   4.1794138
100%  3.496741825  6.29593324  8.82950407  11.82229061  16.503074  18.4289397
```

---

layout: true

# `apply()` : Apply function to rows / columns of a matrix

---

* We will talk about matrix operations in R in more detail later

* It is often useful to apply a function on rows or columns of a matrix


```r
m1 <- matrix(0, nrow = 1000, ncol = 8)
for (i in 1:8)
    m1[, i] <- rnorm(1000, mean = 0, sd = i)
str(m1)
```

```
 num [1:1000, 1:8] -0.30578 -0.00202 -1.51954 0.42576 -0.56283 ...
```

* Note that this is essentially the same as


```r
m2 <- sapply(1:8, function(s) rnorm(n = 1000, mean = 0, sd = s))
str(m2)
```

```
 num [1:1000, 1:8] -0.422 1.624 -0.112 0.151 -0.118 ...
```

---

* Suppose we want to compute the mean for each column of `m1`

* There are several ways to do this:

	- Loop over columns
	
	- Write this as a matrix operation (will discuss later)
	
	- Use the `colMeans()` or `colSums()` function
	

```r
colMeans(m1)
```

```
[1]  0.01122761 -0.03458740  0.11411173 -0.08985753  0.15727037 -0.06138590 -0.26164183  0.23438855
```

```r
colSums(m1) / nrow(m1)
```

```
[1]  0.01122761 -0.03458740  0.11411173 -0.08985753  0.15727037 -0.06138590 -0.26164183  0.23438855
```

---

* However, `colMeans()` / `colSums()` and `rowMeans()` / `rowSums()` are special

* Other summary functions do not have a built-in row-wise / column-wise versions

* `apply()` allows arbitrary functions to be called per row (`MARGIN=1`) or column (`MARGIN=2`) 


```r
apply(m1, 2, mean)
```

```
[1]  0.01122761 -0.03458740  0.11411173 -0.08985753  0.15727037 -0.06138590 -0.26164183  0.23438855
```

```r
apply(m1, 2, sd)
```

```
[1] 1.034117 1.986946 2.934370 4.030210 4.896192 6.101854 6.841550 7.985280
```

```r
apply(m1, 2, IQR)
```

```
[1]  1.382469  2.635595  3.992597  5.556296  6.493805  8.227136  9.728309 10.763844
```

---

* `apply()` also allows additional arguments to be specified


```r
apply(m1, 2, quantile, probs = c(0.25, 0.75))
```

```
          [,1]      [,2]      [,3]      [,4]      [,5]      [,6]      [,7]      [,8]
25% -0.6605589 -1.399304 -1.810924 -2.810065 -3.070904 -4.203320 -5.053099 -4.998478
75%  0.7219097  1.236291  2.181673  2.746231  3.422901  4.023816  4.675210  5.765366
```

* As well as unnamed functions


```r
apply(m1, 2, function(x) median(abs(x)))
```

```
[1] 0.6980885 1.3357257 1.9634437 2.7700312 3.3079633 4.1437022 4.8161335 5.4307825
```

---

* Applying a function row-wise


```r
apply(m1, 1, function(x) which.max(abs(x)))
```

```
   [1] 4 8 8 8 8 7 6 7 8 8 5 5 5 8 8 4 4 4 8 4 6 8 8 7 4 7 7 6 7 8 7 7 8 8 4 4 6 8 7 6 6 8 4 7 7 8 8
  [48] 8 4 6 6 5 8 8 5 7 7 7 8 6 8 5 6 7 7 5 7 6 8 7 8 5 5 7 5 4 6 7 3 2 6 8 7 4 7 8 7 7 7 6 6 6 6 8
  [95] 8 8 4 6 8 6 5 6 7 4 5 7 7 8 4 5 7 6 5 8 8 6 8 6 7 8 7 7 6 5 8 5 6 6 5 4 6 8 8 4 6 8 7 7 8 7 6
 [142] 7 6 6 5 8 7 7 8 7 7 8 7 6 6 3 8 4 8 8 7 8 6 6 6 6 8 8 6 6 5 6 6 7 7 8 8 8 8 6 6 8 7 3 2 8 5 8
 [189] 8 8 5 7 6 7 8 5 7 7 7 8 7 6 8 6 7 8 6 7 8 6 7 7 8 8 6 8 6 7 6 6 5 6 5 8 8 8 8 7 6 7 8 7 8 7 7
 [236] 7 4 6 8 5 7 8 6 8 7 5 7 7 7 7 7 7 4 6 5 4 7 5 6 8 8 7 7 7 8 5 7 8 8 6 7 8 7 8 7 6 8 7 8 3 7 4
 [283] 8 5 3 8 5 8 5 5 5 6 6 8 7 8 7 2 8 7 7 6 7 7 6 5 7 7 7 7 6 8 6 8 8 8 8 7 5 8 8 7 8 6 8 7 8 4 7
 [330] 8 5 8 7 7 4 8 8 7 7 8 8 8 8 7 5 7 6 8 6 7 8 7 6 8 6 6 7 5 7 7 8 8 3 4 8 6 5 5 6 4 8 6 6 3 6 6
 [377] 6 8 7 4 6 8 6 6 7 6 8 8 8 6 6 5 5 6 6 8 7 7 5 7 8 5 8 5 7 8 8 8 6 8 8 7 4 7 8 6 4 8 6 6 7 8 8
 [424] 4 4 7 6 8 7 6 7 7 6 6 8 8 8 6 8 8 5 6 8 5 4 7 5 8 8 6 6 8 8 6 7 7 7 7 8 8 8 5 7 5 3 8 5 4 8 2
 [471] 8 6 8 8 6 8 7 4 5 8 8 8 8 8 5 8 8 8 3 6 2 7 8 8 7 6 8 7 6 8 7 5 5 6 7 5 6 7 4 4 7 8 8 8 3 5 2
 [518] 4 8 8 6 5 7 8 8 8 7 8 5 7 7 8 5 6 8 6 5 6 8 3 5 8 8 5 7 7 7 4 8 6 4 8 5 4 8 6 8 8 8 8 8 7 3 8
 [565] 6 8 8 7 8 5 8 3 7 7 5 5 8 8 6 8 7 6 8 6 5 6 6 8 8 6 6 7 4 7 6 8 8 8 8 7 3 8 4 7 8 6 7 8 7 6 6
 [612] 4 8 8 7 7 6 8 8 8 8 6 6 6 8 5 7 7 4 7 7 6 8 8 7 6 8 7 3 8 7 8 6 8 7 8 6 4 8 8 7 8 8 5 6 8 6 5
 [659] 8 7 7 7 6 4 8 7 8 8 7 3 4 8 7 8 7 8 8 8 8 7 7 7 7 5 4 8 5 6 7 8 5 8 6 8 8 8 7 8 5 8 8 8 8 7 3
 [706] 6 7 6 7 8 8 7 7 7 5 6 8 8 5 8 3 8 7 7 7 5 5 8 7 8 4 4 7 4 7 8 3 5 8 6 8 8 7 5 6 4 8 6 6 8 8 6
 [753] 8 5 7 7 7 8 8 8 6 8 4 5 7 7 8 7 7 5 6 7 8 6 7 5 7 6 5 8 5 7 8 6 7 7 6 7 8 7 5 7 6 4 6 4 7 8 7
 [800] 8 7 5 3 6 6 7 8 4 6 8 8 5 7 6 7 6 8 7 7 8 8 8 8 7 7 7 5 8 5 8 5 8 7 5 3 8 8 8 8 6 6 6 8 7 7 8
 [847] 3 6 8 7 6 7 6 8 5 8 8 3 8 5 8 8 7 6 6 6 7 7 5 6 8 7 5 7 4 8 6 6 8 6 5 6 8 6 7 7 8 4 8 8 6 6 3
 [894] 7 7 8 7 7 5 5 6 6 6 8 6 7 7 8 6 6 7 7 3 5 8 7 7 6 8 6 8 8 6 5 7 7 8 6 6 8 7 7 7 7 5 6 3 8 7 7
 [941] 7 8 6 8 8 8 8 6 8 6 7 7 4 5 6 7 7 8 7 7 6 5 5 7 5 6 6 8 7 8 8 8 5 5 6 8 6 6 6 3 5 6 7 5 7 7 7
 [988] 8 6 7 5 7 6 6 6 6 3 6 6 6
```

---

* Applying a function row-wise


```r
wmax <- apply(m1, 1, function(x) which.max(abs(x)))
table(wmax)
```

```
wmax
  2   3   4   5   6   7   8 
  6  28  59 114 208 259 326 
```

```r
barplot(table(wmax))
```

![plot of chunk unnamed-chunk-13](figures/rapply-3-unnamed-chunk-13-1.png)

---

* `apply()` can also summarize over margins of higher-dimensional arrays


```r
Titanic[,,2,]
```

```
, , Survived = No

      Sex
Class  Male Female
  1st   118      4
  2nd   154     13
  3rd   387     89
  Crew  670      3

, , Survived = Yes

      Sex
Class  Male Female
  1st    57    140
  2nd    14     80
  3rd    75     76
  Crew  192     20
```


---

* `apply()` can also summarize over margins of higher-dimensional arrays


```r
apply(Titanic[,,2,], MARGIN = 3, sum)
```

```
  No  Yes 
1438  654 
```

* More interestingly, the summary can happen over multiple dimensions


```r
apply(Titanic[,,2,], MARGIN = c(2, 3), sum)
```

```
        Survived
Sex        No Yes
  Male   1329 338
  Female  109 316
```

---

layout: true

# `tapply()` : Apply function over "ragged" array

---

* Similar in spirit to `apply()`, but meant for groups of unequal size

* General form: `tapply(X, INDEX, FUN, ..., simplify = TRUE)`

	* `X` is split according to grouping variable(s) `INDEX`
	
	* `FUN` applied to each subset

---

* A simple example we have seen before


```r
with(mtcars, tapply(mpg, am, FUN = mean))
```

```
       0        1 
17.14737 24.39231 
```

---

* `FUN` can be more complicated


```r
with(mtcars, tapply(mpg, am, FUN = summary))
```

```
$`0`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  10.40   14.95   17.30   17.15   19.20   24.40 

$`1`
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  15.00   21.00   22.80   24.39   30.40   33.90 
```

---

* Output of different size leads to list output (controlled by `simplify` as usual)


```r
with(mtcars, tapply(mpg, am, FUN = unique))
```

```
$`0`
 [1] 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4 14.7 21.5 15.5 13.3

$`1`
 [1] 21.0 22.8 32.4 30.4 33.9 27.3 26.0 15.8 19.7 15.0 21.4
```

---

* Grouping by multiple variables is possible

* The default result is an array with groups as margins


```r
with(mtcars, tapply(mpg, list(am, gear), FUN = mean))
```

```
         3      4     5
0 16.10667 21.050    NA
1       NA 26.275 21.38
```

* Some combinations are empty in this case


```r
with(mtcars, tapply(mpg, list(am, gear), FUN = length))
```

```
   3 4  5
0 15 4 NA
1 NA 8  5
```

---

* `tapply()` essentially calls `split()` followed by `lapply()`

* `split()` is often very useful to divide data into subsets for further manipulation

.scrollable400[


```r
str(split(mtcars, mtcars$am))
```

```
List of 2
 $ 0:'data.frame':	19 obs. of  11 variables:
  ..$ mpg : num [1:19] 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 ...
  ..$ cyl : num [1:19] 6 8 6 8 4 4 6 6 8 8 ...
  ..$ disp: num [1:19] 258 360 225 360 147 ...
  ..$ hp  : num [1:19] 110 175 105 245 62 95 123 123 180 180 ...
  ..$ drat: num [1:19] 3.08 3.15 2.76 3.21 3.69 3.92 3.92 3.92 3.07 3.07 ...
  ..$ wt  : num [1:19] 3.21 3.44 3.46 3.57 3.19 ...
  ..$ qsec: num [1:19] 19.4 17 20.2 15.8 20 ...
  ..$ vs  : num [1:19] 1 0 1 0 1 1 1 1 0 0 ...
  ..$ am  : num [1:19] 0 0 0 0 0 0 0 0 0 0 ...
  ..$ gear: num [1:19] 3 3 3 3 4 4 4 4 3 3 ...
  ..$ carb: num [1:19] 1 2 1 4 2 2 4 4 3 3 ...
 $ 1:'data.frame':	13 obs. of  11 variables:
  ..$ mpg : num [1:13] 21 21 22.8 32.4 30.4 33.9 27.3 26 30.4 15.8 ...
  ..$ cyl : num [1:13] 6 6 4 4 4 4 4 4 4 8 ...
  ..$ disp: num [1:13] 160 160 108 78.7 75.7 ...
  ..$ hp  : num [1:13] 110 110 93 66 52 65 66 91 113 264 ...
  ..$ drat: num [1:13] 3.9 3.9 3.85 4.08 4.93 4.22 4.08 4.43 3.77 4.22 ...
  ..$ wt  : num [1:13] 2.62 2.88 2.32 2.2 1.61 ...
  ..$ qsec: num [1:13] 16.5 17 18.6 19.5 18.5 ...
  ..$ vs  : num [1:13] 0 0 1 1 1 1 1 0 1 0 ...
  ..$ am  : num [1:13] 1 1 1 1 1 1 1 1 1 1 ...
  ..$ gear: num [1:13] 4 4 4 4 4 4 4 5 5 5 ...
  ..$ carb: num [1:13] 4 4 1 1 2 1 1 2 2 4 ...
```

]


---

layout: false

# What else?


```r
apropos("apply") # objects with 'apply' in their names
```

```
 [1] "apply"      "dendrapply" "eapply"     "kernapply"  "lapply"     "mapply"     "rapply"    
 [8] "sapply"     "tapply"     "vapply"    
```

* Will not discuss in detail (see documentation):

	* `vapply()`: Safer version of `sapply()` with pre-specified return type

	* `mapply()`: Vectorized apply, where multiple arguments can be varied

	* `eapply()`: Apply over elements in an environment, which we can ignore for now

	* `rapply()`: Recursive apply (over complex lists), which we can also ignore for now

* Others are even more specialized

---

layout: false
class: middle, center

# Questions?

