---
layout: remark
title: Non-Standard Evaluation - 2
subtitle: Introductory Computer Programming
author: Deepayan Sarkar
---

layout: true

# Recap

---

* Lazy evaluation + `substitute()` lets a function obtain the expression supplied to an argument



* A slightly modified version of an example from last time


```r
withCall <- function(e) return(list(value = e, call = substitute(e)))
withCall(sqrt(10))
```

```
$value
[1] 3.162278

$call
sqrt(10)
```

```r
withCall(rbind(rnorm(5), rexp(5)))
```

```
$value
           [,1]      [,2]     [,3]       [,4]      [,5]
[1,] -0.7879692 0.3171686 0.205621 -0.6221789 0.2021104
[2,]  1.6117549 1.1486720 2.943588  2.0161146 1.2034573

$call
rbind(rnorm(5), rexp(5))
```

---

* For example, this is how `plot()` constructs nice axis labels 

```r
x <- seq(-10, 10, length.out = 201)
plot(x = x, y = x * sin(x), type = "l") 
```

![](figures/nseval-1-unnamed-chunk-14-1.png)


---

layout: true

# Non-standard evaluation

---

* Another common use of this technique is to simplify variable references

* Consider the following method to list all `choose(5, 2)` combinations


```r
g <- expand.grid(a = 1:5, b = 1:5)
g$b > g$a
```

```
 [1] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE
[17]  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE
```

```r
g[ g$b > g$a , ]
```

```
   a b
6  1 2
11 1 3
12 2 3
16 1 4
17 2 4
18 3 4
21 1 5
22 2 5
23 3 5
24 4 5
```

---

* Referring to all variables in `g` using `g$...` is cumbersome

* We can in principle simplify this (referring to `g` only once) using


```r
g[ eval(quote(b > a), g), ]
```

```
   a b
6  1 2
11 1 3
12 2 3
16 1 4
17 2 4
18 3 4
21 1 5
22 2 5
23 3 5
24 4 5
```

---

* Several R functions make this even simpler

* A general purpose (generic) function is `with()` 


```r
with
```

```
function (data, expr, ...) 
UseMethod("with")
<bytecode: 0x5570485f5d50>
<environment: namespace:base>
```

```r
with.default
```

```
function (data, expr, ...) 
eval(substitute(expr), data, enclos = parent.frame())
<bytecode: 0x5570486e4e80>
<environment: namespace:base>
```

```r
with(g, b > a) # equivalent to eval(quote(b > a), envir = g)
```

```
 [1] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE
[17]  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE
```

---

* This can be used as follows


```r
g[ with(g, b > a), ]
```

```
   a b
6  1 2
11 1 3
12 2 3
16 1 4
17 2 4
18 3 4
21 1 5
22 2 5
23 3 5
24 4 5
```

---

* For this particular purpose, there is an even more convenient function


```r
subset(g, b > a)
```

```
   a b
6  1 2
11 1 3
12 2 3
16 1 4
17 2 4
18 3 4
21 1 5
22 2 5
23 3 5
24 4 5
```

---

* A popular add-on package for data manipulation, called
  [dplyr](https://dplyr.tidyverse.org/), has a similar function `filter()`


```r
dplyr::filter(g, b > a)
```

```
   a b
1  1 2
2  1 3
3  2 3
4  1 4
5  2 4
6  3 4
7  1 5
8  2 5
9  3 5
10 4 5
```

* [dplyr](https://dplyr.tidyverse.org/) has several other functions that behave similarly

* It is highly recommended for routine data manipulation tasks

---

* Other functions that support similar features are 

	- `transform()`, `dplyr::mutate()` to add new variables that are
      functions of existing variables
	  
	- `dplyr::select()` to select a subset of columns (which `subset()` can also do)

	- `lm()` and many other modeling functions
	
	- `xtabs()` for creating cross-tabulations
	
	- Data visulization packages like lattice and ggplot2 


---

* Another example:


```r
suppressMessages(library(dplyr))
mtcars <- mutate(mtcars, am = factor(am))
summarise(group_by(mtcars, am), mean_mpg = mean(mpg))
```

```
`summarise()` ungrouping output (override with `.groups` argument)
```

```
# A tibble: 2 x 2
  am    mean_mpg
  <fct>    <dbl>
1 0         17.1
2 1         24.4
```

* Equivalent calculation without using add-on packages


```r
with(mtcars, tapply(mpg, am, FUN = mean))
```

```
       0        1 
17.14737 24.39231 
```

---

* A more complicated example:


```r
summarise(group_by(mtcars, am), ols_coef = coef(lm(mpg ~ wt)), which = c("intercept", "slope"))
```

```
`summarise()` regrouping output by 'am' (override with `.groups` argument)
```

```
# A tibble: 4 x 3
# Groups:   am [2]
  am    ols_coef which    
  <fct>    <dbl> <chr>    
1 0        31.4  intercept
2 0        -3.79 slope    
3 1        46.3  intercept
4 1        -9.08 slope    
```

* Equivalent calculation without using add-on packages


```r
sapply(split(mtcars, mtcars$am), function(d) coef(lm(mpg ~ wt, data = d)))
```

```
                    0         1
(Intercept) 31.416055 46.294478
wt          -3.785908 -9.084268
```

---

* Of course, all these can be done using C-type loops, but that is
  much more complicated and error-prone

* I will not explore dplyr any further, but you should learn more about it online

* The `*apply()` type functions are generally useful, and we will discuss them in more detail

---

* Another example: replicating a simulation experiment

* Consider this example from our previous assignment:


```r
n <- 20
x <- sample(n, 2)
max(x) %% min(x) == 0
```

```
[1] TRUE
```

* To estimate the probability of this event, we want to run it several
  times and compute proportion
  
---

* We have seen how to do this using a loop

* An alternative approach is to use the `replicate()` function


```r
replicate(10, {
    x <- sample(n, 2)
    max(x) %% min(x) == 0
})
```

```
 [1] FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE
```

* `replicate()` takes the _expression_ supplied as its second argument and evauates it multiple times


```r
s <- replicate(5000, {
    x <- sample(n, 2)
    max(x) %% min(x) == 0
})
sum(s) / length(s) # estimated probability of success
```

```
[1] 0.249
```

---

layout: true

# Return value of `replicate()`

---

* The return value of `replicate()` depends on what the expression returns when evaluated

* In the above example, each evaluation results in a scalar logical

* In that case, the results are aggregated to produce a vector
--

* If the result is always a vector of same length (greater than one), the result is combined into a matrix


```r
quantile(rnorm(500), probs = c(0.25, 0.5, 0.75))
```

```
         25%          50%          75% 
-0.702808139 -0.002276398  0.665647040 
```

```r
replicate(6, quantile(rnorm(500), probs = c(0.25, 0.5, 0.75)))
```

```
           [,1]        [,2]        [,3]        [,4]        [,5]        [,6]
25% -0.68870713 -0.69191772 -0.69278339 -0.73923964 -0.75623401 -0.57924938
50%  0.03048848 -0.07158648 -0.04418099 -0.04573097 -0.03000628  0.06520286
75%  0.75822470  0.54225323  0.56965756  0.61200126  0.68320268  0.77058196
```

---

* If the result has inconsistent length, the result is a list


```r
set.seed(20200101)
replicate(6, unique(sample(10, 5, replace = TRUE)))
```

```
[[1]]
[1] 1 4 5 8

[[2]]
[1] 4 7 8 6

[[3]]
[1] 10  9  5  2  1

[[4]]
[1] 6 4 1 2

[[5]]
[1] 6 9 2 3

[[6]]
[1] 1 9 6 2 4
```

---

* This may sometimes lead to unanticipated behaviour


```r
set.seed(20200101)
replicate(2, unique(sample(10, 5, replace = TRUE)))
```

```
     [,1] [,2]
[1,]    1    4
[2,]    4    7
[3,]    5    8
[4,]    8    6
```
--

* When output length is known to be variable, it is better to
  explicitly disable simplification


```r
set.seed(20200101)
replicate(2, unique(sample(10, 5, replace = TRUE)), simplify = FALSE) # always return list
```

```
[[1]]
[1] 1 4 5 8

[[2]]
[1] 4 7 8 6
```


---

layout: false
class: middle, center

# Questions?

